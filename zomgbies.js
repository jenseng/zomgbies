// Generated by CoffeeScript 1.6.3
(function() {
  var __slice = [].slice,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  (function($) {
    var $status, AGENT_HEIGHT, Agent, AgentList, Binoculars, Board, Colt, FarmHouse, Fence, Game, Grenade, Grenades, HALF_PI, Item, MotorHome, MouseTarget, PI, Player, QUARTER_PI, RotatedRectangleStructure, RotatedSquareStructure, SPRITE_HEIGHT, SPRITE_WIDTH, SQRT_2, Stats, Structure, Sword, TAU, TEN_DEGREES, Tower, Tracker, Weapon, Zombie, Zomgbie, abs, atan2, ceil, cos, factory, floor, gravity, hypotenuse, lastRead, makeObservation, max, min, normalizeDirection, pick, pixelsPerMeter, pow, rand, read, register, round, sectorSize, sin, sqrt, sum, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
    sectorSize = 36;
    pixelsPerMeter = 36;
    gravity = 9.8 * pixelsPerMeter;
    abs = Math.abs;
    cos = Math.cos;
    sin = Math.sin;
    atan2 = Math.atan2;
    rand = Math.random;
    floor = Math.floor;
    ceil = Math.ceil;
    round = Math.round;
    sqrt = Math.sqrt;
    min = Math.min;
    max = Math.max;
    pow = Math.pow;
    PI = Math.PI;
    TAU = PI * 2;
    HALF_PI = PI / 2;
    QUARTER_PI = PI / 4;
    TEN_DEGREES = PI / 18;
    SQRT_2 = sqrt(2);
    SPRITE_WIDTH = 36;
    SPRITE_HEIGHT = 72;
    AGENT_HEIGHT = 58;
    $status = $("<div>", {
      style: "position: relative; z-index: -1; overflow: hidden; width: 0; height: 0;",
      "aria-live": "polite",
      "role": "log"
    }).appendTo($(document.body));
    lastRead = new Date().getTime();
    read = function(text) {
      var now;
      now = new Date().getTime();
      if (!lastRead || now > lastRead + 1000) {
        lastRead = now;
        return $status.text(text);
      }
    };
    pick = function() {
      return arguments[floor(rand() * arguments.length)];
    };
    makeObservation = function() {
      return read(pick("this is terrifying", "you're not doing very well", "this is hard to watch", "not bad", "pro tip: kill the zombies", "nicely done", "watch out", "look out", "here they come", "lol", "wow", "haha", "that was amazing", "good job", "gotta be quick", "you've got this", "you're a natural", "does my voice sound weird to you?", "i've got a bad feeling about this", "nice shooting, tex"));
    };
    normalizeDirection = function(direction) {
      if (direction > PI) {
        direction -= TAU;
      } else if (direction < -PI) {
        direction += TAU;
      }
      return direction;
    };
    hypotenuse = function(a, b) {
      return sqrt(a * a + b * b);
    };
    sum = function(array) {
      var cnt, i, _i, _len;
      cnt = 0;
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        i = array[_i];
        cnt += i;
      }
      return cnt;
    };
    register = function(name, constructor) {
      if (this.types == null) {
        this.types = {};
      }
      constructor.prototype.name = name;
      return this.types[name] = constructor;
    };
    factory = function() {
      var args, name;
      name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(this.types[name], args, function(){});
    };
    Zomgbie = function($canvas, options) {
      return new Game($canvas, options).start();
    };
    Zomgbie.registerExtension = function(type, name, constructor) {
      if (type === 'weapon') {
        return Weapon.register(name, constructor);
      } else if (type === 'structure') {
        return Structure.register(name, constructor);
      }
    };
    Game = (function() {
      function Game($canvas, options) {
        this.$canvas = $canvas;
        this.run = __bind(this.run, this);
        this.keyUp = __bind(this.keyUp, this);
        this.keyDown = __bind(this.keyDown, this);
        this.start = __bind(this.start, this);
        this.pause = __bind(this.pause, this);
        this.config = $.extend({}, this.config, options, true);
        this.restart();
        this.addListeners();
      }

      Game.prototype.restart = function() {
        var args, config, name, _i, _len, _ref, _ref1, _ref2;
        config = this.config;
        this.delayedActions = [];
        this.board = new Board(this, this.$canvas, 2400, 2400);
        this.agents = new AgentList(this);
        this.mouseTarget = new MouseTarget(this);
        _ref1 = (_ref = config.structures) != null ? _ref : {};
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          _ref2 = _ref1[_i], name = _ref2[0], args = 2 <= _ref2.length ? __slice.call(_ref2, 1) : [];
          this.agents.push(Structure.factory.apply(Structure, [name, this].concat(__slice.call(args))));
        }
        this.stats = new Stats(this);
        this.stats.setStatus("ZOMG! LOOK OUT!", 75);
        this.player = new Player(this, this.mouseTarget);
        this.agents.push(this.player);
        this.board.items = [this.mouseTarget, this.agents].concat(__slice.call(this.player.weapons), [this.stats]);
        this.setPursuitThreshold(config.pursuitThreshold);
        this.addInitialZombies();
        this.tickTime = floor(1000 / config.ticksPerSecond);
        return this.times = {
          run: [],
          render: []
        };
      };

      Game.prototype.config = {
        ticksPerSecond: 30,
        maxZombies: 100,
        maxSpawnsPerTick: 50,
        pursuitThreshold: 200,
        patrolCorrection: 3,
        pursueTargets: true,
        mode: 'play',
        weapons: ['colt']
      };

      Game.prototype.addListeners = function() {
        var $doc,
          _this = this;
        $doc = $(document);
        this.$canvas.on('mousemove', function(e) {
          var _ref;
          if (!_this.running) {
            return;
          }
          _this.mouseTarget.set(_this.board.x + e.clientX, _this.board.y + e.clientY * 2);
          return (_ref = _this.player) != null ? _ref.mouseMove() : void 0;
        });
        this.$canvas.on('mousedown', function(e) {
          var _ref, _ref1;
          if (_this.running) {
            _this.mouseTarget.set(_this.board.x + e.clientX, _this.board.y + e.clientY * 2);
            if ((_ref = _this.player) != null ? _ref.alive : void 0) {
              return (_ref1 = _this.player) != null ? _ref1.mouseDown() : void 0;
            } else {
              return _this.restart();
            }
          } else {
            return _this.start();
          }
        });
        this.$canvas.on('mouseup', function(e) {
          var _ref;
          if (!_this.running) {
            return;
          }
          _this.mouseTarget.set(_this.board.x + e.clientX, _this.board.y + e.clientY * 2);
          return (_ref = _this.player) != null ? _ref.mouseUp() : void 0;
        });
        $doc.on('keydown', this.keyDown);
        $doc.on('keyup', this.keyUp);
        if (this.config.resize) {
          $(window).on('resize', this.board.resize);
        }
        $(window).blur(this.pause);
        $(window).focus(this.start);
      };

      Game.prototype.pause = function() {
        this.$canvas.css({
          cursor: 'default'
        });
        return this.running = false;
      };

      Game.prototype.start = function() {
        this.$canvas.css({
          cursor: 'none'
        });
        this.running = true;
        this.times.nextTick = new Date().getTime();
        return this.run();
      };

      Game.prototype.keyDown = function(e) {
        var key, _ref, _ref1;
        key = e.which;
        if (this.running) {
          if (key === 27 || key === 80) {
            this.pause();
          } else if ((_ref = this.player) != null ? _ref.alive : void 0) {
            if ((_ref1 = this.player) != null) {
              _ref1.keyDown(key);
            }
          } else if (key === 32) {
            this.restart();
          }
        } else {
          if (key === 27 || key === 13 || key === 32 || key === 80) {
            this.start();
          }
        }
      };

      Game.prototype.keyUp = function(e) {
        var key, _ref;
        key = e.which;
        if (this.running) {
          if ((_ref = this.player) != null) {
            _ref.keyUp(key);
          }
        }
      };

      Game.prototype.time = function(label, code) {
        var ret, start, times;
        start = new Date().getTime();
        ret = code.call(this);
        times = this.times[label];
        if (times.length > 100) {
          times.shift();
        }
        times.push(new Date().getTime() - start);
        return ret;
      };

      Game.prototype.run = function() {
        var now, _base;
        if ((_base = this.times).nextTick == null) {
          _base.nextTick = this.times.started = new Date().getTime();
        }
        this.times.nextTick += this.tickTime;
        if (750 * rand() < 1) {
          makeObservation();
        }
        this.time('run', function() {
          this.maybeAddZombies();
          this.agents.move();
          this.board.move();
          return this.agents.sort();
        });
        this.time('render', function() {
          return this.board.render();
        });
        if (this.pursuitThreshold > this.config.pursuitThreshold) {
          this.setPursuitThreshold(this.pursuitThreshold - 2);
        }
        this.runDelayedActions();
        now = new Date().getTime();
        if (this.times.nextTick < now) {
          this.times.nextTick = now;
        }
        if (this.running) {
          setTimeout(this.run, this.times.nextTick - now);
        }
      };

      Game.prototype.addInitialZombies = function() {
        var i, zombie, _i, _ref;
        for (i = _i = 0, _ref = floor(this.config.maxZombies / 5); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          zombie = new Zombie(this, this.player);
          zombie.randomStart(this.board);
          while (abs(zombie.x - this.player.x) < this.pursuitThreshold || abs(zombie.y + this.player.y) < this.pursuitThreshold) {
            zombie.randomStart(this.board);
          }
          this.agents.push(zombie);
        }
      };

      Game.prototype.maybeAddZombies = function() {
        var agents, config, i, maxZombies, numZombies, toAdd, zombie, _i;
        agents = this.agents;
        config = this.config;
        numZombies = agents.numZombies;
        maxZombies = config.maxZombies;
        if (numZombies < maxZombies && rand() * 80 < 1) {
          toAdd = min(ceil(rand() * config.maxSpawnsPerTick), maxZombies - numZombies);
          if (rand() < 0.2) {
            if (toAdd === 1) {
              read(numZombies === 0 ? "zombie" : pick("another zombie", "yet another", "zombie", "walker"));
            } else if (toAdd < 4) {
              read(pick("zombies", "here they come", "here come a couple", "yikes"));
            } else {
              read(pick("uh oh", "oh no", "damn", "oh crap a lot of zombies", "here comes the horde", "whoa that's a lot", "they just keep coming"));
            }
          }
          for (i = _i = 0; 0 <= toAdd ? _i < toAdd : _i > toAdd; i = 0 <= toAdd ? ++_i : --_i) {
            zombie = new Zombie(this, this.player);
            zombie.randomEdgeStart(this.board);
            this.agents.push(zombie);
          }
        }
      };

      Game.prototype.runDelayedActions = function() {
        var action, delayedActions, i, len, _results;
        i = 0;
        delayedActions = this.delayedActions;
        len = delayedActions.length;
        _results = [];
        while (i < len) {
          action = delayedActions[i];
          if (--action[0]) {
            _results.push(i++);
          } else {
            action[1].call(this);
            delayedActions.splice(i, 1);
            _results.push(len--);
          }
        }
        return _results;
      };

      Game.prototype.addBinoculars = function() {
        var _this = this;
        return this.delayedActions.push([
          150, function() {
            var binoculars;
            binoculars = new Binoculars;
            binoculars.set(_this.mouseTarget.x, _this.mouseTarget.y);
            _this.mouseTarget.listener = binoculars;
            return _this.board.items.push(binoculars);
          }
        ]);
      };

      Game.prototype.gameOver = function() {
        var message, messages;
        this.config.patrolCorrection = 1;
        this.addBinoculars();
        messages = this.config.messages.gameOver;
        message = pick.apply(this, messages);
        read("game over. " + message);
        read = function() {};
        this.stats.setStatus(message);
      };

      Game.prototype.setPursuitThreshold = function(newVal) {
        this.pursuitThreshold = newVal;
        this.pursuitThresholdSquared = newVal * newVal;
      };

      Game.prototype.noise = function(factor) {
        if (factor == null) {
          factor = 1;
        }
        return this.setPursuitThreshold(min(this.pursuitThreshold + factor * this.config.pursuitThreshold, 3 * this.config.pursuitThreshold));
      };

      return Game;

    })();
    Board = (function() {
      function Board(game, $canvas, width, height) {
        this.game = game;
        this.width = width;
        this.height = height;
        this.resize = __bind(this.resize, this);
        this.config = this.game.config;
        $canvas.css({
          maxWidth: this.width,
          maxHeight: this.height / 2
        });
        this.canvas = $canvas[0];
        this.context = this.canvas.getContext('2d');
        this.resize();
        this.background = new Image();
        this.background.src = "images/background.png";
        this.x = this.width / 2 - this.visibleWidth / 2;
        this.y = this.height / 2 - this.visibleHeight / 2;
      }

      Board.prototype.resize = function() {
        this.visibleWidth = this.canvas.offsetWidth;
        this.visibleHeight = this.canvas.offsetHeight * 2;
        this.x = min(this.x, this.width - this.visibleWidth);
        this.y = min(this.y, this.height - this.visibleHeight);
        if (this.items) {
          this.render();
        }
      };

      Board.prototype.visible = function(x, y, sizeX, sizeYTop, sizeYBottom) {
        if (sizeYBottom == null) {
          sizeYBottom = sizeYTop;
        }
        return x + sizeX >= this.x && x - sizeX <= this.x + this.visibleWidth && y + sizeYBottom >= this.y && y - sizeYTop <= this.y + this.visibleHeight;
      };

      Board.prototype.makeVisible = function(agent, bufferX, bufferYBottom, bufferYTop) {
        var mouse, oldX, oldY;
        if (bufferYTop == null) {
          bufferYTop = bufferYBottom;
        }
        oldX = this.x;
        oldY = this.y;
        if (agent.x - bufferX < this.x) {
          this.x = max(agent.x - bufferX, 0);
        } else if (agent.x + bufferX > this.x + this.visibleWidth) {
          this.x = min(agent.x + bufferX, this.width) - this.visibleWidth;
        }
        if (agent.y - bufferYTop < this.y) {
          this.y = max(agent.y - bufferYTop, 0);
        } else if (agent.y + bufferYBottom > this.y + this.visibleHeight) {
          this.y = min(agent.y + bufferYBottom, this.height) - this.visibleHeight;
        }
        mouse = this.game.mouseTarget;
        if (true || agent !== mouse) {
          mouse.x += this.x - oldX;
          return mouse.y += this.y - oldY;
        }
      };

      Board.prototype.move = function() {
        var _ref;
        if ((_ref = this.game.player) != null ? _ref.manual : void 0) {
          return this.makeVisible(this.game.player, 64, 64, 128);
        } else {
          return this.makeVisible(this.game.mouseTarget, 24, 48);
        }
      };

      Board.prototype.renderDebug = function() {
        var context, slope, xMax, xMin, yMax, yMin, ySlope, zones, _i, _len, _ref, _results;
        if (zones = this.game.agents.stackingZones) {
          context = this.context;
          context.strokeStyle = '#88f';
          _results = [];
          for (_i = 0, _len = zones.length; _i < _len; _i++) {
            _ref = zones[_i], xMin = _ref[0], yMin = _ref[1], xMax = _ref[2], yMax = _ref[3], ySlope = _ref[4], slope = _ref[5];
            context.beginPath();
            context.strokeRect(xMin - this.x, (yMin - this.y) / 2, xMax - xMin, (yMax - yMin) / 2);
            context.moveTo(xMin - this.x, (ySlope - this.y) / 2);
            context.lineTo(xMax - this.x, (ySlope - this.y + slope * (xMax - xMin)) / 2);
            _results.push(context.stroke());
          }
          return _results;
        }
      };

      Board.prototype.renderMenu = function() {
        var context;
        context = this.context;
        context.fillStyle = 'rgba(128,0,0,0.75)';
        context.fillRect(0, 0, this.width, this.height);
        context.textBaseline = "top";
        context.fillStyle = '#fff';
        context.strokeStyle = '#400';
        return this.renderText("PAUSED", 50, "center", "center");
      };

      Board.prototype.renderText = function(text, fontSize, xAlign, yAlign) {
        var canvas, context, height, i, line, lineHeight, lines, metrics, newLines, width, x, y, _i, _len;
        text = text.toUpperCase();
        canvas = this.canvas;
        width = canvas.width;
        context = this.context;
        lines = text.split("\n");
        context.font = "bold " + fontSize + "px \"Arial Black\", Arial, sans-serif";
        context.lineWidth = max(1.5, fontSize / 18);
        lineHeight = fontSize * 1.25;
        i = 0;
        while (i < lines.length) {
          line = lines[i];
          metrics = context.measureText(line);
          if (metrics.width >= width) {
            newLines = this.wrapText(line, context, width);
            newLines.splice(0, 0, i, 1);
            i += newLines.length - 1;
            lines.splice.apply(lines, newLines);
          } else {
            i++;
          }
        }
        height = lines.length * lineHeight;
        x = 10;
        y = 5;
        if (xAlign === 'center') {
          x = width / 2;
        } else if (xAlign === 'right') {
          x = width - 10;
        }
        if (yAlign === 'center') {
          y = (canvas.height - height) / 2;
        } else if (yAlign === 'bottom') {
          y = canvas.height - height - 5;
        }
        context.textAlign = xAlign;
        for (_i = 0, _len = lines.length; _i < _len; _i++) {
          line = lines[_i];
          context.fillText(line, x, y);
          context.strokeText(line, x, y);
          y += lineHeight;
        }
        context.lineWidth = 1;
      };

      Board.prototype.wrapText = function(text, context, width) {
        var line, lines, metrics, testLine, word, words, _i, _len;
        words = text.split(/\s/);
        lines = [];
        line = '';
        for (_i = 0, _len = words.length; _i < _len; _i++) {
          word = words[_i];
          testLine = line + word + ' ';
          metrics = context.measureText(testLine);
          if (line && metrics.width > width) {
            lines.push(line);
            line = word + ' ';
          } else {
            line = testLine;
          }
        }
        lines.push(line);
        return lines;
      };

      Board.prototype.render = function() {
        var item, _i, _len, _ref;
        if (this.canvas.height !== this.visibleHeight / 2 || this.canvas.width !== this.visibleWidth) {
          this.canvas.height = this.visibleHeight / 2;
          this.canvas.width = this.visibleWidth;
        }
        this.context.clearRect(0, 0, this.width, this.height);
        this.context.drawImage(this.background, -this.x, 250 - this.y / 2);
        if (this.config.debug) {
          this.renderDebug();
        }
        _ref = this.items;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          item = _ref[_i];
          item.render(this);
        }
        if (!this.game.running) {
          this.renderMenu();
        }
      };

      return Board;

    })();
    Stats = (function() {
      function Stats(game) {
        this.game = game;
        this.config = this.game.config;
      }

      Stats.prototype.kills = 0;

      Stats.prototype.killStreak = 0;

      Stats.prototype.maxKillStreak = 0;

      Stats.prototype.maxCombo = 0;

      Stats.prototype.hitRatio = 0;

      Stats.prototype.totalShots = 0;

      Stats.prototype.totalHitShots = 0;

      Stats.prototype.maxStatusTime = 150;

      Stats.prototype.addShotInfo = function(kills) {
        this.totalShots++;
        if (kills > 1 && kills > this.maxCombo) {
          this.maxCombo = kills;
        }
        this.kills += kills;
        if (kills) {
          this.totalHitShots++;
          this.killStreak += kills;
          if (this.killStreak > this.maxKillStreak) {
            this.maxKillStreak = this.killStreak;
          }
        } else {
          this.killStreak = 0;
        }
        this.hitRatio = this.totalHitShots / this.totalShots;
      };

      Stats.prototype.setStatus = function(status, statusTime) {
        this.status = status;
        this.statusTime = statusTime != null ? statusTime : this.maxStatusTime;
      };

      Stats.prototype.renderDebug = function(board) {
        var agents, game, sector, sectorCount, sectors, tickTime, times;
        game = this.game;
        tickTime = game.tickTime;
        times = game.times;
        agents = game.agents;
        sectors = agents.sectors;
        sectorCount = 0;
        for (sector in sectors) {
          sectorCount++;
        }
        board.renderText("sectors: " + sectorCount + "\nagents: " + agents.length + "\nrun: " + ((sum(times.run) / tickTime).toFixed(2)) + "%\nrender: " + ((sum(times.render) / tickTime).toFixed(2)) + "%", 24, "left", "top");
      };

      Stats.prototype.render = function(board) {
        var canvas, context, player, weapon;
        canvas = board.canvas;
        context = board.context;
        player = this.game.player;
        weapon = player.weapon;
        context.save();
        context.textBaseline = "top";
        context.globalAlpha = 0.8;
        context.fillStyle = player.alive ? '#d44' : '#874';
        context.strokeStyle = player.alive ? '#100' : '#110';
        if (this.config.debug) {
          this.renderDebug(board);
        }
        board.renderText("kills: " + this.kills + "\nstreak: " + this.killStreak + " (" + this.maxKillStreak + ")\ncombo: " + this.maxCombo, 24, "left", "bottom");
        board.renderText("walkers: " + this.game.agents.numZombies + "\n< weapon: " + weapon.name + " >\nammo: " + (weapon.shots || "...") + (weapon.cache ? " / " + weapon.cache : ""), 24, "right", "bottom");
        if (this.statusTime) {
          context.globalAlpha = 0.6 * min(1, 4 * this.statusTime / this.maxStatusTime);
          board.renderText(this.status, 36, "center", "center");
          this.statusTime--;
        }
        return context.restore();
      };

      return Stats;

    })();
    Agent = (function() {
      function Agent(game) {
        this.game = game;
        this.config = game != null ? game.config : void 0;
        this.agents = game != null ? game.agents : void 0;
        this.player = game != null ? game.player : void 0;
      }

      Agent.prototype.collisionMechanism = function() {
        return 'rebound';
      };

      Agent.prototype.collisionTangent = function(collisionInfo) {
        return normalizeDirection(HALF_PI + atan2(this.y - collisionInfo.y, this.x - collisionInfo.x));
      };

      Agent.prototype.checkCollision = function(otherX, otherY, otherSize, otherZ, otherHeight) {
        var diffX, diffY, distSquared, distX, distY, minDist, minDistSquared;
        diffY = this.y - otherY;
        distY = abs(diffY);
        minDist = (this.size + otherSize) / 2;
        minDistSquared = minDist * minDist;
        if (distY > minDist) {
          return false;
        }
        diffX = this.x - otherX;
        distX = abs(diffX);
        if (distX > minDist) {
          return false;
        }
        distSquared = distX * distX + distY * distY;
        if (distSquared > minDistSquared) {
          return false;
        }
        if (this.z !== otherZ && !this.structure && (this.z + this.height < otherZ || otherZ + otherHeight < this.z)) {
          return false;
        }
        return {
          direction: atan2(diffY, diffX),
          distSquared: distSquared
        };
      };

      Agent.prototype.sectorRange = function(x, size) {
        if (x == null) {
          x = this.x;
        }
        if (size == null) {
          size = this.size;
        }
        if (x == null) {
          return;
        }
        return [floor((x - size / 2) / sectorSize), floor((x + size / 2) / sectorSize)];
      };

      Agent.prototype.set = function(x, y, z, size, height) {
        if (z == null) {
          z = this.z;
        }
        if (size == null) {
          size = this.size;
        }
        if (height == null) {
          height = this.height;
        }
        x = round(x);
        y = round(y);
        z = round(z);
        if (!(this.x === x && this.y === y && this.z === z && this.size === size && this.height === height)) {
          this.agents.set(this, x, y, z, size, height);
        }
      };

      Agent.prototype.nextMove = function() {
        return true;
      };

      Agent.prototype.render = function() {};

      Agent.prototype.renderShadow = function() {};

      return Agent;

    })();
    AgentList = (function() {
      function AgentList(game) {
        this.game = game;
        this.sectors = {};
        this.byStacking = [];
        this.byDistance = [];
      }

      AgentList.prototype.length = 0;

      AgentList.prototype.numZombies = 0;

      AgentList.prototype.push = function(item) {
        this.length++;
        this.byDistance.push(item);
        this.byStacking.push(item);
        return item;
      };

      AgentList.prototype.distanceSorterFrd = function(a, b) {
        return a.distSquaredFrd - b.distSquaredFrd;
      };

      AgentList.prototype.distanceSorter = function(a, b) {
        return a.distSquared - b.distSquared;
      };

      AgentList.prototype.stackingSorter = function(a, b) {
        return a.stacking - b.stacking;
      };

      AgentList.prototype.sort = function() {
        var byDistance, byStacking, i, _i, _ref;
        byDistance = this.byDistance;
        byStacking = this.byStacking;
        byDistance.sort(this.distanceSorterFrd);
        byStacking.sort(this.stackingSorter);
        for (i = _i = 0, _ref = this.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          byDistance[i].distanceIdx = i;
          byStacking[i].stackingIdx = i;
        }
      };

      AgentList.prototype.remove = function(agent) {
        var byDistance, byStacking, i, len, _i, _j, _ref, _ref1;
        len = --this.length;
        byDistance = this.byDistance;
        byStacking = this.byStacking;
        byDistance.splice(agent.distanceIdx, 1);
        for (i = _i = _ref = agent.distanceIdx; _ref <= len ? _i < len : _i > len; i = _ref <= len ? ++_i : --_i) {
          byDistance[i].distanceIdx--;
        }
        byStacking.splice(agent.stackingIdx, 1);
        for (i = _j = _ref1 = agent.stackingIdx; _ref1 <= len ? _j < len : _j > len; i = _ref1 <= len ? ++_j : --_j) {
          byStacking[i].stackingIdx--;
        }
        this.removeFromSectors(agent, agent.sectorRange());
      };

      AgentList.prototype.bestMoveFor = function(agent, direction, distance) {
        var adjacentStructure, collision, collisions, currDir, currDist, currMove, factor, i, j, multiplier, player, _i, _j, _len, _ref, _ref1, _ref2;
        factor = rand() > 0.5 ? 1 : -1;
        adjacentStructure = false;
        player = this.game.player;
        _ref = [1, 0.25];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          i = _ref[_i];
          currDist = i * distance;
          for (j = _j = 0; _j < 23; j = ++_j) {
            multiplier = factor * (j % 2 || -1) * round(j / 2 + 0.25);
            currDir = normalizeDirection(direction + multiplier * TEN_DEGREES);
            currMove = this.validateMoveFor(agent, currDir, currDist);
            collisions = currMove.collisions;
            if (!collisions.length) {
              if (j && abs(normalizeDirection(agent.direction - currDir)) > HALF_PI) {
                if (agent !== player) {
                  agent.rest(floor(rand() * 20 + 20), true);
                }
              }
              return {
                distance: currDist * currMove.factor,
                direction: currDir,
                x: currMove.x,
                y: currMove.y
              };
            } else if (j === 0 && ((_ref1 = collisions[0]) != null ? (_ref2 = _ref1.agent) != null ? _ref2.structure : void 0 : void 0)) {
              adjacentStructure = true;
            }
            if (adjacentStructure && j >= 16) {
              break;
            }
          }
          if (adjacentStructure) {
            break;
          }
        }
        if (collision = this.closestCollision(agent)) {
          currDir = normalizeDirection(PI + collision.direction);
          return {
            distance: distance,
            direction: currDir,
            x: agent.x + 0.5 * distance * cos(currDir),
            y: agent.y + 0.5 * distance * sin(currDir)
          };
        }
      };

      AgentList.prototype.collisionsFor = function(agent, x, y, size) {
        var collision, collisions, height, i, other, range, sector, sectors, seen, z, _i, _j, _len, _ref, _ref1;
        if (x == null) {
          x = agent.x;
        }
        if (y == null) {
          y = agent.y;
        }
        if (size == null) {
          size = agent.size;
        }
        z = agent.z;
        height = agent.height;
        range = agent.sectorRange(x, size);
        sectors = this.sectors;
        collisions = [];
        seen = {};
        for (i = _i = _ref = range[0], _ref1 = range[1]; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = _ref <= _ref1 ? ++_i : --_i) {
          sector = sectors[i];
          if (sector == null) {
            continue;
          }
          for (_j = 0, _len = sector.length; _j < _len; _j++) {
            other = sector[_j];
            if (!(other !== agent && !seen[other.distanceIdx])) {
              continue;
            }
            seen[other.distanceIdx] = true;
            if (collision = other.checkCollision(x, y, size, z, height)) {
              collisions.push({
                agent: other,
                distSquared: collision.distSquared,
                direction: collision.direction
              });
            }
          }
        }
        return collisions;
      };

      AgentList.prototype.closestCollision = function(agent) {
        var collisions;
        collisions = this.collisionsFor(agent);
        if (collisions.length) {
          collisions.sort(this.distanceSorter);
        }
        return collisions[0];
      };

      AgentList.prototype.validateMoveFor = function(agent, direction, distance) {
        var collision, collisions, factor, other, x, xDiff, y, yDiff, _i, _len, _ref;
        x = agent.x;
        y = agent.y;
        xDiff = distance * cos(direction);
        yDiff = distance * sin(direction);
        factor = 1;
        collisions = [];
        _ref = this.collisionsFor(agent, x + xDiff, y + yDiff);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          collision = _ref[_i];
          other = collision.agent;
          if (other.decayTime) {
            factor = 0.6 + 0.4 * (1 - other.decayTime / other.maxDecayTime);
          } else if (other.sleepTime) {
            factor = 0.6;
          } else if (other.object) {
            factor = 0.8;
          } else {
            collisions.push(collision);
          }
        }
        return {
          x: x + xDiff * factor,
          y: y + yDiff * factor,
          factor: factor,
          collisions: collisions
        };
      };

      AgentList.prototype.set = function(agent, x, y, z, size, height) {
        var rangeOld;
        rangeOld = agent.sectorRange();
        agent.x = x;
        agent.y = y;
        agent.z = z;
        agent.size = size;
        agent.height = height;
        agent.stacking = this.stackingFor(x, y, agent);
        if (rangeOld) {
          this.setSectors(agent, rangeOld, agent.sectorRange());
        } else {
          this.addToSectors(agent, agent.sectorRange());
        }
      };

      AgentList.prototype.setSectors = function(agent, rangeOld, range) {
        var newEnd, newStart, oldEnd, oldStart, sectors;
        oldStart = rangeOld[0], oldEnd = rangeOld[1];
        newStart = range[0], newEnd = range[1];
        sectors = this.sectors;
        if (oldStart === newStart && oldEnd === newEnd) {
          return;
        }
        if (oldStart < newStart) {
          this.removeFromSectors(agent, [oldStart, min(newStart - 1, oldEnd)]);
        } else if (oldStart > newStart) {
          this.addToSectors(agent, [newStart, min(oldStart - 1, newEnd)]);
        }
        if (oldEnd > newEnd) {
          this.removeFromSectors(agent, [max(oldStart, newEnd + 1), oldEnd]);
        } else if (oldEnd < newEnd) {
          this.addToSectors(agent, [max(newStart, oldEnd + 1), newEnd]);
        }
      };

      AgentList.prototype.addToSectors = function(agent, range) {
        var i, sector, sectors, _i, _ref, _ref1;
        sectors = this.sectors;
        for (i = _i = _ref = range[0], _ref1 = range[1]; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = _ref <= _ref1 ? ++_i : --_i) {
          sector = sectors[i] != null ? sectors[i] : sectors[i] = [];
          sector.push(agent);
        }
      };

      AgentList.prototype.removeFromSectors = function(agent, range) {
        var i, sector, sectors, _i, _ref, _ref1;
        sectors = this.sectors;
        for (i = _i = _ref = range[0], _ref1 = range[1]; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = _ref <= _ref1 ? ++_i : --_i) {
          sector = sectors[i];
          sector.splice(sector.indexOf(agent), 1);
          if (!sector.length) {
            delete sectors[i];
          }
        }
      };

      AgentList.prototype.move = function() {
        var agent, byDistance, i, len, numZombies;
        numZombies = 0;
        byDistance = this.byDistance;
        len = this.length;
        i = 0;
        while (i < len) {
          agent = byDistance[i];
          if (!agent.nextMove()) {
            this.remove(agent);
            len--;
          } else {
            if (agent.alive && agent.zombie) {
              numZombies++;
            }
            i++;
          }
        }
        this.numZombies = numZombies;
      };

      AgentList.prototype.render = function(board) {
        var agent, _i, _j, _len, _len1, _ref, _ref1;
        _ref = this.byStacking;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          agent = _ref[_i];
          agent.renderShadow(board);
        }
        this.game.mouseTarget.renderShadow(board);
        _ref1 = this.byStacking;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          agent = _ref1[_j];
          agent.render(board);
        }
      };

      AgentList.prototype.addStackingZones = function(structure, newZones) {
        var zones, _ref;
        zones = (_ref = this.stackingZones) != null ? _ref : [];
        this.stackingZones = zones.concat(newZones);
      };

      AgentList.prototype.stackingFor = function(x, y, agent) {
        var h, origY, scale, slope, xMax, xMin, yBase, yBaseFrd, yLine, yMax, yMin, ySlope, _i, _len, _ref, _ref1;
        origY = y;
        _ref = this.stackingZones;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          _ref1 = _ref[_i], xMin = _ref1[0], yMin = _ref1[1], xMax = _ref1[2], yMax = _ref1[3], ySlope = _ref1[4], slope = _ref1[5];
          if (x < xMin || x > xMax || y < yMin || y > yMax) {
            continue;
          }
          yLine = ySlope + (x - xMin) * slope;
          if (y < yLine) {
            h = yLine - yMin;
            yBaseFrd = yBase = yMin;
          } else {
            h = yMax - yLine;
            yBase = yLine;
            yBaseFrd = yMin + (yMax - yMin) / 2;
          }
          scale = h / ((yMax - yMin) / 2);
          y = yBaseFrd + (y - yBase) / scale;
        }
        return y;
      };

      return AgentList;

    })();
    Weapon = (function() {
      function Weapon(game, player) {
        this.game = game;
        this.player = player;
        this.closest = __bind(this.closest, this);
      }

      Weapon.register = register;

      Weapon.factory = factory;

      Weapon.prototype.ready = true;

      Weapon.prototype.disable = function(time, callback) {
        this.disableTime = time;
        this.disableCallback = callback;
        this.ready = false;
      };

      Weapon.prototype.closest = function() {
        var agent, _i, _len, _ref;
        _ref = this.game.agents.byDistance;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          agent = _ref[_i];
          if (agent.alive && agent.zombie && !agent.sleepTime) {
            return agent;
          }
        }
      };

      Weapon.prototype.nextMove = function() {
        if (this.disableTime && !--this.disableTime) {
          this.ready = true;
          this.disableCallback();
        }
        return true;
      };

      Weapon.prototype.render = function() {};

      Weapon.prototype.fire = function() {};

      Weapon.prototype.fired = function() {};

      return Weapon;

    })();
    Item = (function(_super) {
      __extends(Item, _super);

      function Item() {
        var _ref, _ref1;
        Item.__super__.constructor.apply(this, arguments);
        this.gravityPerTick = gravity / ((_ref = this.game) != null ? (_ref1 = _ref.config) != null ? _ref1.ticksPerSecond : void 0 : void 0);
      }

      Item.prototype.decel = 6;

      Item.prototype.item = true;

      Item.prototype.zRest = true;

      Item.prototype.nextMove = function() {
        var agents, collision, currMove, diff, direction, hit, other, speed, tan, zRest;
        speed = this.speed;
        zRest = this.zRest;
        if (speed > 0 || !zRest) {
          agents = this.agents;
          direction = this.direction;
          currMove = agents.validateMoveFor(this, direction, speed);
          if (collision = currMove.collisions[0]) {
            other = collision.agent;
            tan = other.collisionTangent(currMove);
            diff = normalizeDirection(tan - direction);
            if (abs(diff) > QUARTER_PI) {
              tan = normalizeDirection(tan + PI);
              diff = normalizeDirection(diff + PI);
            }
            if (other.item) {
              if (diff < 0) {
                other.direction = tan + QUARTER_PI;
              } else {
                other.direction = tan - QUARTER_PI;
              }
              other.speed = speed * abs(sin(diff));
              direction = tan;
              speed *= abs(cos(diff));
            } else {
              if (other.structure) {
                speed *= 0.8;
              } else {
                other.stun(10);
                speed *= 0.2;
              }
              direction = normalizeDirection(direction + diff + diff);
            }
            this.direction = direction;
          }
          this.z += this.zSpeed;
          if (this.z <= 0) {
            if (!zRest) {
              hit = this.sounds.hit;
              hit.load();
              hit.play();
              zRest = true;
              this.zSpeed = 0;
            }
            this.z = 0;
            speed -= this.decel;
            if (speed < 0) {
              speed = 0;
            }
            this.speed = speed;
          } else if (!zRest) {
            this.zSpeed -= this.gravityPerTick;
          }
          this.zRest = zRest;
          this.set(this.x + speed * cos(direction), this.y + speed * sin(direction));
        }
        return true;
      };

      return Item;

    })(Agent);
    Grenade = (function(_super) {
      __extends(Grenade, _super);

      function Grenade() {
        this.explode = __bind(this.explode, this);
        var pin;
        Grenade.__super__.constructor.apply(this, arguments);
        pin = this.sounds.pin;
        pin.load();
        pin.play();
        this.agents.push(this);
      }

      Grenade.prototype.sounds = {
        pin: $('<audio src="audio/pin.mp3" preload="auto"></audio>')[0],
        hit: $('<audio src="audio/grenadehit.m4a" preload="auto"></audio>')[0],
        explode: $('<audio src="audio/explode.mp3" preload="auto"></audio>')[0]
      };

      Grenade.prototype.timeToExplode = 45;

      Grenade.prototype.timeToThrow = 15;

      Grenade.prototype.trackable = true;

      Grenade.prototype.killRadiusSquared = 60 * 60;

      Grenade.prototype.maimRadiusSquared = 120 * 120;

      Grenade.prototype.stunRadiusSquared = 200 * 200;

      Grenade.prototype.distractDiameter = 1000;

      Grenade.prototype.speed = 64;

      Grenade.prototype.size = 6;

      Grenade.prototype.height = 6;

      Grenade.prototype.throwAt = function(target) {
        var direction, dist, distX, distY, inertia, maxSpeed, ogTarget, optimalSpeed, optimalSpeedSide, player, relativeOptimalSpeed, startOffset, x, y;
        if (this.exploded) {
          return;
        }
        player = this.player;
        x = player.x, y = player.y;
        startOffset = player.size / 2;
        this.thrown = true;
        this.zRest = false;
        if (target) {
          ogTarget = target;
          target = target.projectedLocation(this.timeToExplode * this.game.tickTime);
          distX = target.x - x;
          distY = target.y - y;
          dist = max(hypotenuse(distX, distY) - startOffset, 1);
          optimalSpeed = sqrt(dist * this.gravityPerTick) * 0.85;
          direction = atan2(distY, distX);
        } else {
          optimalSpeed = this.speed;
          direction = normalizeDirection(rand() * TAU);
        }
        x += startOffset * cos(direction);
        y += startOffset * sin(direction);
        this.set(x, y, player.height * 0.75);
        this.direction = direction;
        optimalSpeedSide = optimalSpeed / SQRT_2;
        inertia = player.currentSpeed * cos(player.direction - this.direction);
        relativeOptimalSpeed = hypotenuse(optimalSpeedSide, optimalSpeedSide - inertia);
        maxSpeed = this.speed * (optimalSpeed / relativeOptimalSpeed);
        if (optimalSpeed > maxSpeed) {
          optimalSpeedSide *= maxSpeed / optimalSpeed;
        }
        this.zSpeed = optimalSpeedSide;
        this.speed = optimalSpeedSide;
        if (rand() < 0.25) {
          read(pick("nice throw", "good arm", "good throw", "nice", "you're nolan ryan"));
        }
      };

      Grenade.prototype.animationTime = 240;

      Grenade.prototype.animationTimeExplosion = 15;

      Grenade.prototype.explode = function() {
        var agents, explode, hit, pin, player, sounds;
        agents = this.game.agents;
        sounds = this.sounds;
        pin = sounds.pin;
        hit = sounds.hit;
        explode = sounds.explode;
        pin.pause();
        hit.pause();
        explode.load();
        explode.play();
        if (!this.thrown) {
          player = this.player;
          this.thrown = true;
          this.set(player.x, player.y, 0);
          agents.push(this);
        }
        this.speed = 0;
        this.zSpeed = 0;
        this.exploded = true;
      };

      Grenade.prototype.caughtBy = function(agent) {
        if (agent.distractTime) {
          agent.distractTime = 1;
        }
      };

      Grenade.prototype.nextMove = function() {
        var agent, casualties, distractDiameter, game, hitCount, info, killRadiusSquared, maimRadiusSquared, player, stunRadiusSquared, _i, _len,
          _this = this;
        if (this.exploded) {
          this.nextMove = function() {
            return --_this.animationTime;
          };
          hitCount = 0;
          player = this.player;
          killRadiusSquared = this.killRadiusSquared;
          maimRadiusSquared = this.maimRadiusSquared;
          stunRadiusSquared = this.stunRadiusSquared;
          distractDiameter = this.distractDiameter;
          game = this.game;
          casualties = game.agents.collisionsFor(this, this.x, this.y, distractDiameter);
          for (_i = 0, _len = casualties.length; _i < _len; _i++) {
            info = casualties[_i];
            agent = info.agent;
            if (!agent.alive) {
              continue;
            }
            if (info.distSquared < killRadiusSquared) {
              hitCount++;
              agent.kill();
            } else if (info.distSquared < maimRadiusSquared) {
              agent.maim(floor(50 + 100 * (1 - info.distSquared / maimRadiusSquared)));
            } else if (agent !== this.player) {
              if (info.distSquared < stunRadiusSquared) {
                agent.stun(floor(25 + 50 * (1 - info.distSquared / stunRadiusSquared)));
              } else {
                agent.distract(this, 60 + floor(60 * rand()), distractDiameter);
              }
            }
          }
          game.stats.addShotInfo(hitCount);
          game.noise(0.5);
          if (hitCount === 0) {
            read(pick("waste", "total waste", "got nothin", "next time", "do you even aim bro?", "so close", "ooh", "d'oh", "almost", "not quite"));
          } else {
            read(pick("hahaha", "awesome, " + hitCount, "got " + hitCount, "haha, you blew up " + hitCount, "ha, got " + hitCount, "that'll teach them", "it's raining arms", "i love grenades", "strong work", "so strong", "heart grenades so much"));
          }
          this.animationTime--;
        } else {
          if (!this.thrown && (!this.timeToThrow || !--this.timeToThrow) && this.throwCb) {
            this.throwCb();
            this.thrown = true;
          }
          if (this.thrown) {
            Grenade.__super__.nextMove.apply(this, arguments);
          }
          if (!--this.timeToExplode) {
            this.explode();
          }
        }
        return true;
      };

      Grenade.prototype.renderShadow = function(board) {
        var context, game, gradient, x, y;
        if (!board.visible(this.x, this.y, 20, 20)) {
          return;
        }
        context = board.context;
        game = this.game;
        x = this.x - board.x;
        y = this.y - board.y;
        context.save();
        context.scale(1, 0.5);
        if (this.exploded) {
          context.globalAlpha = this.animationTime / Grenade.prototype.animationTime;
          context.beginPath();
          context.arc(x, y, 40, 0, TAU);
          gradient = context.createRadialGradient(x, y, 40, x, y, 0);
          gradient.addColorStop(0, 'rgba(0,0,0,0)');
          gradient.addColorStop(0.8, 'rgba(32,24,16,0.5)');
          gradient.addColorStop(1, 'rgba(32,24,16,1)');
          context.fillStyle = gradient;
          context.fill();
        } else if (this.thrown) {
          context.beginPath();
          context.globalAlpha = 0.2;
          context.arc(x, y, 3, 0, TAU);
          context.fillStyle = '#000';
          context.fill();
        }
        return context.restore();
      };

      Grenade.prototype.render = function(board) {
        var animationTime, b, baseX, baseY, circles, context, fade, g, gray, i, opacity, r, rad, size, x, y, _i;
        if (!board.visible(this.x, this.y, 25, 200, 10)) {
          return;
        }
        baseX = this.x - board.x;
        baseY = this.y - board.y;
        context = board.context;
        if (this.exploded) {
          animationTime = this.animationTimeExplosion - (Grenade.prototype.animationTime - this.animationTime);
          if (!(animationTime > 0)) {
            return;
          }
          context.save();
          fade = animationTime < 12 ? animationTime / 12 : 1;
          fade = fade * fade * fade;
          context.globalAlpha = fade;
          size = animationTime > 10 ? 3 * (16 - animationTime) : 5 + animationTime / 2;
          circles = size * 4;
          for (i = _i = 0; 0 <= circles ? _i < circles : _i > circles; i = 0 <= circles ? ++_i : --_i) {
            context.beginPath();
            rad = (1 + 2 * rand()) * size;
            x = (5 - 10 * rand()) * size;
            y = (2 - 4 * rand()) * size;
            y -= (1 - animationTime / 15) * 200;
            context.arc(baseX + x, baseY / 2 - this.z + y, rad, 0, TAU);
            gray = (1 - fade) * (96 + rand() * 128);
            r = floor(gray + fade * 255);
            g = floor(gray + fade * (192 + rand() * 64));
            b = floor(gray + fade * (rand() * 128));
            opacity = 0.5 * rand() + 0.1;
            context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + opacity + ')';
            context.fill();
          }
          context.restore();
        } else if (this.thrown) {
          context.beginPath();
          context.arc(baseX, baseY / 2 - this.z - 3, 3, 0, TAU);
          context.fillStyle = '#ab9';
          context.fill();
          context.strokeStyle = '#786';
          context.stroke();
        }
      };

      Grenade.prototype.whenTimeToThrow = function(throwCb) {
        this.throwCb = throwCb;
      };

      return Grenade;

    })(Item);
    Grenades = (function(_super) {
      __extends(Grenades, _super);

      function Grenades() {
        _ref = Grenades.__super__.constructor.apply(this, arguments);
        return _ref;
      }

      Grenades.prototype.shots = '';

      Grenades.prototype.fire = function() {
        this.grenade = new Grenade(this.game);
        this.firing = true;
        this.ready = false;
      };

      Grenades.prototype.fired = function() {
        var _this = this;
        if (!this.firing) {
          return;
        }
        if (this.grenade.throwCb) {
          return;
        }
        this.grenade.whenTimeToThrow(function() {
          _this.grenade.throwAt(_this.closest());
          _this.grenade = null;
          _this.firing = false;
          return _this.ready = true;
        });
      };

      return Grenades;

    })(Weapon);
    Sword = (function(_super) {
      __extends(Sword, _super);

      function Sword() {
        _ref1 = Sword.__super__.constructor.apply(this, arguments);
        return _ref1;
      }

      Sword.prototype.shots = '';

      return Sword;

    })(Weapon);
    Colt = (function(_super) {
      __extends(Colt, _super);

      function Colt() {
        Colt.__super__.constructor.apply(this, arguments);
        this.reload();
      }

      Colt.prototype.sounds = {
        fire: $('<audio src="audio/colt.mp3" preload="auto"></audio>')[0],
        reload: $('<audio src="audio/reload.m4a" preload="auto"></audio>')[0]
      };

      Colt.prototype.shots = 0;

      Colt.prototype.cache = '';

      Colt.prototype.maxVisibleTime = 5;

      Colt.prototype.fire = function() {
        var agent, agents, byDistance, closest, direction, fire, game, hitCount, hitMargin, len, offBy, player, _i, _len,
          _this = this;
        closest = this.closest();
        direction = rand() * TAU;
        player = this.player;
        game = this.game;
        agents = game.agents;
        byDistance = agents.byDistance;
        len = agents.length;
        fire = this.sounds.fire;
        hitCount = 0;
        game.noise();
        if (closest) {
          direction = closest.optimalDirection;
          direction += PI * (rand() / 45 - 1 / 90);
          for (_i = 0, _len = byDistance.length; _i < _len; _i++) {
            agent = byDistance[_i];
            if (!(agent.alive && agent !== player)) {
              continue;
            }
            hitMargin = abs(atan2(agent.size / 4, sqrt(agent.distSquaredFrd)));
            offBy = abs(agent.optimalDirection - direction);
            if (offBy < hitMargin) {
              hitCount++;
              agent.kill();
            }
          }
        }
        game.stats.addShotInfo(hitCount);
        direction = normalizeDirection(direction + PI);
        this.lastShot = {
          x: player.x,
          y: player.y,
          direction: direction,
          visibleTime: this.maxVisibleTime
        };
        this.shots--;
        if (hitCount === 0) {
          read(pick("miss", "whiff", "so close", "next time"));
        } else if (hitCount === 1) {
          read(pick("nice shot", "got one", "got 'em", "haha", "headshot"));
        } else {
          read(pick("oh wow", "got " + hitCount, "mega kill", hitCount + " for 1", "haha, amazing"));
        }
        fire.load();
        fire.play();
        this.disable(24, function() {
          if (!_this.shots) {
            return _this.reload();
          }
        });
      };

      Colt.prototype.reload = function() {
        var reload,
          _this = this;
        reload = this.sounds.reload;
        read(pick("reload quick", "quick", "hurry", "c'mon", "let's go", "faster", "oh man"));
        reload.load();
        reload.play();
        this.disable(90, function() {
          return _this.shots = 6;
        });
      };

      Colt.prototype.render = function(board) {
        var context, direction, lastShot, x, y;
        context = board.context;
        lastShot = this.lastShot;
        if (!(lastShot && board.visible(lastShot.x, lastShot.y, 600, 600))) {
          return;
        }
        if (lastShot != null ? lastShot.visibleTime : void 0) {
          x = lastShot.x, y = lastShot.y, direction = lastShot.direction;
          x -= board.x;
          y -= board.y;
          context.save();
          context.beginPath();
          context.moveTo(x, y / 2 - 40);
          context.lineTo(x + 600 * cos(direction), (y + 600 * sin(direction)) / 2 - 56);
          context.strokeStyle = '#ccc';
          context.globalAlpha = lastShot.visibleTime / this.maxVisibleTime;
          context.stroke();
          context.restore();
          lastShot.visibleTime--;
        }
      };

      return Colt;

    })(Weapon);
    Weapon.register('grenades', Grenades);
    Weapon.register('sword', Sword);
    Weapon.register('colt', Colt);
    Tracker = (function(_super) {
      __extends(Tracker, _super);

      function Tracker(game, target) {
        this.target = target;
        Tracker.__super__.constructor.apply(this, arguments);
      }

      Tracker.prototype.alive = true;

      Tracker.prototype.health = 10;

      Tracker.prototype.trackable = true;

      Tracker.prototype.size = 24;

      Tracker.prototype.height = 50;

      Tracker.prototype.pursuitWobble = 10;

      Tracker.prototype.patrolWobble = 30;

      Tracker.prototype.maxDecayTime = 160;

      Tracker.prototype.deviations = 0;

      Tracker.prototype.collisionMechanism = function(other) {
        return 'avoid';
      };

      Tracker.prototype.randomStart = function(board) {
        this.direction = normalizeDirection(rand() * TAU);
        this.set(rand() * board.width, rand() * board.height);
      };

      Tracker.prototype.randomEdgeStart = function(board) {
        var height, sprite, startPos, width;
        sprite = this.game.config.sprites[this.sprite];
        width = board.width;
        height = board.height;
        startPos = rand() * 2 * (width + height);
        if (startPos < width) {
          this.direction = HALF_PI;
          this.set(startPos, 0);
        } else if (startPos < width + height) {
          this.direction = PI;
          this.set(width + sprite.width / 2, startPos - width);
        } else if (startPos < 2 * width + height) {
          this.direction = 3 * HALF_PI;
          this.set(startPos - width - height, height + sprite.height * 2);
        } else {
          this.direction = 0;
          this.set(-sprite.width / 2, startPos - 2 * width - height);
        }
      };

      Tracker.prototype.render = function(board) {
        var context, decayTime, maxDecayTime, sprite, x, y;
        if (!board.visible(this.x, this.y, 50, 100, 50)) {
          return;
        }
        context = board.context;
        sprite = this.game.config.sprites[this.sprite];
        decayTime = this.decayTime;
        maxDecayTime = this.maxDecayTime;
        x = this.x - board.x;
        y = this.y - board.y;
        if (!(this.alive || decayTime)) {
          return;
        }
        if (decayTime || this.sleepTime) {
          context.save();
          if (decayTime) {
            context.globalAlpha = decayTime > maxDecayTime / 2 ? 1 : 2 * decayTime / maxDecayTime;
          }
          context.translate(round(x), round(y / 2));
          context.rotate(HALF_PI);
          context.drawImage(sprite, -sprite.width / 2 - 6, -sprite.height / 2);
          context.restore();
        } else {
          context.drawImage(sprite, round(x - sprite.width / 2), round(y / 2 - AGENT_HEIGHT));
        }
      };

      Tracker.prototype.renderShadow = function(board) {
        var context, halfLife, time, x, y;
        if (!board.visible(this.x, this.y, 50, 50)) {
          return;
        }
        context = board.context;
        x = this.x - board.x;
        y = this.y - board.y;
        context.save();
        context.scale(1, 0.5);
        context.globalAlpha = 0.05;
        context.beginPath();
        if (this.y !== this.stacking && this.config.debug) {
          context.arc(x, y, 100, 0, TAU);
          context.fillStyle = '#00f';
        } else {
          context.arc(x, y, 10, 0, TAU);
          context.fillStyle = '#000';
        }
        context.fill();
        if (time = this.sleepTime || this.decayTime) {
          if (this.blood == null) {
            this.blood = this.bloodStain();
          }
          halfLife = (this.totalSleepTime || this.maxDecayTime) / 2;
          context.globalAlpha = time < halfLife ? time / halfLife : 1;
          context.drawImage(this.blood, x - 36, y - 36);
        }
        return context.restore();
      };

      Tracker.prototype.bloodStain = function() {
        var canvas, circles, context, i, rad, size, x, y, _i;
        canvas = document.createElement('canvas');
        context = canvas.getContext('2d');
        canvas.width = 72;
        canvas.height = 72;
        circles = this.alive ? 5 : 10;
        size = 5;
        for (i = _i = 0; 0 <= circles ? _i < circles : _i > circles; i = 0 <= circles ? ++_i : --_i) {
          context.beginPath();
          rad = (1 + rand()) * size;
          x = 36 + 10 * (0.5 - rand()) * size;
          y = 36 + 5 * (0.5 - rand()) * size;
          context.arc(x, y, rad, 0, TAU);
          context.fillStyle = 'rgba(160,48,48,1)';
          context.fill();
        }
        return canvas;
      };

      Tracker.prototype.nextMove = function() {
        this.currentSpeed = 0;
        if (!this.alive) {
          if (this.decayTime) {
            this.decayTime--;
          }
          return this.decayTime;
        }
        this.checkProximity();
        if (this.sleepTime) {
          --this.sleepTime || this.revive();
        } else if (this.manual && !this.restRequired) {
          this.manualMove();
        } else if (this.game.config.pursueTargets && this.targetVisible() && !this.restRequired) {
          this.pursue();
        } else if (this.restTime) {
          this.rest();
        } else if (rand() < 0.02) {
          this.rest(ceil(rand() * 40));
        } else {
          this.patrol();
        }
        return true;
      };

      Tracker.prototype.targetVisible = function() {
        var distX, distY, game, target, threshold, _ref2, _ref3;
        target = this.target;
        game = this.game;
        threshold = (_ref2 = this.pursuitThreshold) != null ? _ref2 : game.pursuitThreshold;
        distX = this.distX;
        distY = this.distY;
        if (!target || target.alive === false) {
          return false;
        }
        if (distX > threshold || distX < -threshold) {
          return false;
        }
        if (distY > threshold || distY < -threshold) {
          return false;
        }
        return this.distSquared < ((_ref3 = this.pursuitThresholdSquared) != null ? _ref3 : game.pursuitThresholdSquared);
      };

      Tracker.prototype.distract = function(fakeTarget, distractTime, distractRadius) {
        this.rest(round(rand() * 20), true);
        this.targetTrackTime = this.distractTime = distractTime;
        this.pursuitThreshold = distractRadius;
        this.pursuitThresholdSquared = distractRadius * distractRadius;
        if (this.targetFrd == null) {
          this.targetFrd = this.target;
        }
        this.target = fakeTarget;
      };

      Tracker.prototype.checkProximity = function() {
        var correction, distX, distY, optimalDirection, projected, target, targetFrd, x, y;
        target = this.target;
        if (target != null ? target.trackable : void 0) {
          x = this.x;
          y = this.y;
          if (this.distractTime) {
            targetFrd = this.targetFrd;
            if (--this.distractTime) {
              distX = targetFrd.x - x;
              distY = targetFrd.y - y;
              this.distSquaredFrd = distX * distX + distY * distY;
            } else {
              this.target = target = targetFrd;
              this.targetFrd = null;
              this.pursuitThreshold = null;
              this.pursuitThresholdSquared = null;
            }
          }
          distX = this.distX = target.x - x;
          distY = this.distY = target.y - y;
          optimalDirection = this.optimalDirection = atan2(distY, distX);
          this.distSquared = distX * distX + distY * distY;
          if (!this.distractTime) {
            this.distSquaredFrd = this.distSquared;
          }
          if (this.predictFactor && target.currentSpeed) {
            if (abs(normalizeDirection(this.optimalDirection - target.direction)) < HALF_PI) {
              projected = target.projectedLocation(500);
              correction = this.predictFactor * normalizeDirection(atan2(projected.y - y, projected.x - x) - optimalDirection);
            } else {
              correction = this.predictFactor * normalizeDirection(PI - (target.direction - optimalDirection));
            }
            this.optimalDirection = normalizeDirection(optimalDirection + correction);
          }
        } else {
          this.targetTrackTime = 0;
        }
      };

      Tracker.prototype.wobble = function(degrees) {
        if (!degrees) {
          return 0;
        }
        return PI * (rand() * degrees / 90 - degrees / 180);
      };

      Tracker.prototype.manualMove = function() {
        var board, direction, height, width, x, y;
        direction = normalizeDirection(atan2(this.manualY, this.manualX));
        if (this.manualX || this.manualY) {
          this.move(direction, this.speed);
        }
        board = this.game.board;
        x = this.x, y = this.y;
        width = board.width, height = board.height;
        if (x < 12) {
          this.x = 12;
        }
        if (x > width - 12) {
          this.x = width - 12;
        }
        if (y < 128) {
          this.y = 128;
        }
        if (y > height - 12) {
          this.y = height - 12;
        }
      };

      Tracker.prototype.pursue = function() {
        var direction, distSquared, game, minCaptureDist, speed, speedSquared, target;
        if (this.targetTrackTime) {
          this.targetTrackTime--;
        } else {
          this.targetTrackTime = 120;
        }
        target = this.target;
        distSquared = this.distSquared;
        speed = this.speed;
        speedSquared = this.speedSquared;
        minCaptureDist = speed + (this.size + target.size) / 2;
        game = this.game;
        if (distSquared < minCaptureDist * minCaptureDist) {
          if (distSquared < speedSquared) {
            this.set(target.x, target.y);
          } else {
            this.move(this.optimalDirection, speed);
          }
          target.caughtBy(this);
          this.restTime = 20;
        } else {
          direction = normalizeDirection(this.optimalDirection + this.wobble(this.pursuitWobble));
          if (this !== game.player) {
            speed *= (1 + rand() + (1 - pow(min(1, distSquared / game.pursuitThresholdSquared), 2))) / 4;
          }
          this.move(direction, speed);
        }
      };

      Tracker.prototype.patrol = function() {
        var difference, direction;
        direction = normalizeDirection(this.direction + this.wobble(this.patrolWobble));
        if (this.target) {
          difference = normalizeDirection(this.optimalDirection - direction);
          if (abs(difference) > HALF_PI) {
            direction += (difference > 0 ? 1 : -1) * PI * this.game.config.patrolCorrection / 180;
          }
        }
        this.move(direction, this.speed / 3);
      };

      Tracker.prototype.rest = function(duration, required) {
        if (duration == null) {
          this.restTime--;
          if (!this.restTime) {
            return this.restRequired = false;
          }
        } else {
          this.restTime = duration;
          return this.restRequired = required;
        }
      };

      Tracker.prototype.move = function(direction, distance) {
        var frd;
        if (frd = this.agents.bestMoveFor(this, direction, distance)) {
          this.direction = frd.direction;
          this.currentSpeed = frd.distance;
          this.set(frd.x, frd.y);
        }
      };

      Tracker.prototype.kill = function() {
        this.set(this.x, this.y, this.z, 32, 8);
        this.alive = false;
        this.decayTime = this.maxDecayTime;
      };

      Tracker.prototype.maim = function(time) {
        this.set(this.x, this.y, this.z, 32, 8);
        this.totalSleepTime = this.sleepTime = floor(time);
      };

      Tracker.prototype.stun = function(time) {
        this.rest(time, true);
      };

      Tracker.prototype.revive = function() {
        this.set(this.x, this.y, this.z, Tracker.prototype.size, Tracker.prototype.height);
        return this.blood = null;
      };

      Tracker.prototype.projectedLocation = function(time) {
        var direction, projectedDist, ticks, x, y;
        ticks = time / this.game.tickTime;
        projectedDist = this.currentSpeed * ticks;
        direction = this.direction;
        x = this.x + projectedDist * cos(direction);
        y = this.y + projectedDist * sin(direction);
        return {
          x: x,
          y: y
        };
      };

      return Tracker;

    })(Agent);
    Zombie = (function(_super) {
      __extends(Zombie, _super);

      function Zombie(game, target) {
        Zombie.__super__.constructor.apply(this, arguments);
        this.speed = 0.5 * (1 + rand()) * this.maxSpeed;
        this.speedSquared = this.speed * this.speed;
        this.sprite = 1 + floor(rand() * 15);
        this.predictFactor = rand() * rand();
      }

      Zombie.prototype.maxSpeed = 6;

      Zombie.prototype.zombie = true;

      return Zombie;

    })(Tracker);
    Binoculars = (function() {
      function Binoculars() {
        this.mask = document.createElement('canvas');
        this.maskContext = this.mask.getContext('2d');
        this.visible = false;
      }

      Binoculars.prototype.set = function(x, y) {
        this.x = x;
        this.y = y;
      };

      Binoculars.prototype.fadeInTime = 150;

      Binoculars.prototype.render = function(board) {
        var canvas, context, eyeOffset, gradient, height, mask, maskContext, radius, width, x, y;
        context = board.context;
        canvas = board.canvas;
        width = canvas.width;
        height = canvas.height;
        radius = min(width, height) / 5;
        eyeOffset = 0.7;
        gradient;
        x = this.x - board.x;
        y = (this.y - board.y) / 2;
        mask = this.mask;
        maskContext = this.maskContext;
        mask.width = width;
        mask.height = height;
        maskContext.clearRect(0, 0, width, height);
        gradient = maskContext.createRadialGradient(x - eyeOffset * radius, y, radius * 0.9, x - eyeOffset * radius, y, radius);
        gradient.addColorStop(0, 'rgba(0,0,0,0.95)');
        gradient.addColorStop(1, 'rgba(0,0,0,0)');
        maskContext.fillStyle = gradient;
        maskContext.arc(x - eyeOffset * radius, y, radius, 0, TAU);
        maskContext.fill();
        gradient = maskContext.createRadialGradient(x + eyeOffset * radius, y, radius * 0.9, x + eyeOffset * radius, y, radius);
        gradient.addColorStop(0, 'rgba(0,0,0,0.95)');
        gradient.addColorStop(1, 'rgba(0,0,0,0)');
        maskContext.fillStyle = gradient;
        maskContext.arc(x + eyeOffset * radius, y, radius, 0, TAU);
        maskContext.fill();
        maskContext.globalCompositeOperation = 'xor';
        maskContext.fillStyle = 'rgba(0,0,0,1)';
        maskContext.fillRect(0, 0, width, height);
        context.save();
        if (this.fadeInTime) {
          this.fadeInTime--;
        }
        context.globalAlpha = 1 - (this.fadeInTime / Binoculars.prototype.fadeInTime);
        context.drawImage(mask, 0, 0);
        context.restore();
      };

      Binoculars.prototype.renderShadow = function() {};

      return Binoculars;

    })();
    MouseTarget = (function() {
      function MouseTarget(game) {
        var board;
        this.game = game;
        board = game.board;
        this.x = board.width / 2;
        this.y = board.height / 2;
      }

      MouseTarget.prototype.trackable = true;

      MouseTarget.prototype.size = 0;

      MouseTarget.prototype.caughtBy = function() {};

      MouseTarget.prototype.set = function(x, y) {
        var _ref2;
        this.x = x;
        this.y = y;
        return (_ref2 = this.listener) != null ? _ref2.set(this.x, this.y) : void 0;
      };

      MouseTarget.prototype.render = function() {};

      MouseTarget.prototype.renderShadow = function(board) {
        var context, player;
        player = this.player != null ? this.player : this.player = this.game.player;
        if (!(player && player.alive && !player.manual && player.currentSpeed)) {
          return;
        }
        context = board.context;
        context.save();
        context.scale(1, 0.5);
        context.globalAlpha = 0.75;
        context.beginPath();
        context.translate(this.x - board.x, this.y - board.y);
        context.rotate(QUARTER_PI);
        context.arc(0, 0, 10, 0, TAU);
        context.strokeStyle = '#ccb';
        context.stroke();
        context.fillStyle = '#ccb';
        context.fillRect(-20, -1, 40, 3);
        context.fillRect(-1, -20, 3, 40);
        context.restore();
      };

      return MouseTarget;

    })();
    Player = (function(_super) {
      __extends(Player, _super);

      function Player(game, mouseTarget) {
        var name;
        Player.__super__.constructor.apply(this, arguments);
        this.set(mouseTarget.x, mouseTarget.y);
        this.speedSquared = this.speed * this.speed;
        this.directionKeysPressed = {};
        this.weapons = (function() {
          var _i, _len, _ref2, _results;
          _ref2 = game.config.weapons;
          _results = [];
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            name = _ref2[_i];
            _results.push(Weapon.factory(name, game, this));
          }
          return _results;
        }).call(this);
        this.weapon = this.weapons[0];
      }

      Player.prototype.pursuitWobble = 0;

      Player.prototype.speed = 12;

      Player.prototype.direction = 0;

      Player.prototype.sprite = 0;

      Player.prototype.collisionMechanism = function(other) {
        if (other.zombie) {
          return 'attack';
        } else {
          return 'avoid';
        }
      };

      Player.prototype.targetVisible = function() {
        return true;
      };

      Player.prototype.kill = function() {
        Player.__super__.kill.apply(this, arguments);
        this.weapon.ready = false;
        this.game.gameOver();
      };

      Player.prototype.infect = function() {
        var zombie;
        this.kill();
        this.decayTime = 0;
        zombie = new Zombie(this.game, this);
        zombie.sprite = 0;
        zombie.direction = 0;
        zombie.set(this.x, this.y + 1);
        zombie.maim(40);
        this.agents.push(zombie);
      };

      Player.prototype.caughtBy = function() {
        return this.infect();
      };

      Player.prototype.directionKeys = {
        37: 'W',
        38: 'N',
        39: 'E',
        40: 'S',
        65: 'W',
        87: 'N',
        68: 'E',
        83: 'S'
      };

      Player.prototype.inferManualDirection = function() {
        var directions, key;
        directions = {};
        for (key in this.directionKeysPressed) {
          if (this.directionKeysPressed[key]) {
            directions[this.directionKeys[key]] = 1;
          }
        }
        this.manualX = directions.E ^ directions.W ? directions.E || -1 : 0;
        this.manualY = directions.S ^ directions.N ? directions.S || -1 : 0;
      };

      Player.prototype.mouseDown = function() {
        if (this.alive && this.weapon.ready && !this.sleepTime) {
          this.weapon.fire();
        }
      };

      Player.prototype.mouseUp = function() {
        if (this.alive && this.weapon.firing && !this.sleepTime) {
          this.weapon.fired();
        }
      };

      Player.prototype.mouseMove = function() {
        if (this.manual && !this.manualX && !this.manualY) {
          this.manual = false;
        }
      };

      Player.prototype.keyDown = function(key) {
        if (!this.alive) {
          return;
        }
        if (this.directionKeys[key]) {
          this.manual = true;
          this.directionKeysPressed[key] = true;
          this.inferManualDirection();
        } else if (this.weapon.ready && !this.sleepTime) {
          if (key === 32) {
            this.weapon.fire();
          } else if (key === 188 || key === 33) {
            this.prevWeapon();
          } else if (key === 190 || key === 34 || key === 13) {
            this.nextWeapon();
          }
        }
      };

      Player.prototype.keyUp = function(key) {
        if (!this.alive) {
          return;
        }
        if (this.directionKeys[key]) {
          this.directionKeysPressed[key] = false;
          this.inferManualDirection();
        } else if (key === 32 && this.weapon.firing) {
          this.weapon.fired();
        }
      };

      Player.prototype.prevWeapon = function() {
        this.weapons.unshift(this.weapons.pop());
        this.weapon = this.weapons[0];
      };

      Player.prototype.nextWeapon = function() {
        this.weapons.push(this.weapons.shift());
        this.weapon = this.weapons[0];
      };

      Player.prototype.renderShadow = function(board) {
        var context;
        Player.__super__.renderShadow.apply(this, arguments);
        if (!board.visible(this.x, this.y, this.game.pursuitThreshold, this.game.pursuitThreshold)) {
          return;
        }
        context = board.context;
        context.save();
        context.scale(1, 0.5);
        context.globalAlpha = 0.25;
        context.beginPath();
        context.arc(this.x - board.x, this.y - board.y, this.game.pursuitThreshold, 0, TAU);
        context.fillStyle = '#ffe';
        context.fill();
        context.restore();
      };

      Player.prototype.nextMove = function() {
        var ret;
        ret = Player.__super__.nextMove.apply(this, arguments);
        this.weapon.nextMove();
        return ret;
      };

      return Player;

    })(Tracker);
    Structure = (function(_super) {
      __extends(Structure, _super);

      Structure.register = register;

      Structure.factory = factory;

      Structure.prototype.imageXOffset = 0;

      Structure.prototype.imageYOffset = 0;

      function Structure(game, x, y) {
        var image, zones;
        this.game = game;
        this.x = x;
        this.y = y;
        Structure.__super__.constructor.apply(this, arguments);
        if (this.imageSrc) {
          this.image = image = new Image();
          image.src = this.imageSrc;
        }
        this.imageXOffset || (this.imageXOffset = this.size / 2);
        if (this.stacking == null) {
          this.stacking = this.y;
        }
        this.agents.addToSectors(this, this.sectorRange());
        if (zones = this.stackingZones) {
          this.agents.addStackingZones(this, zones);
        }
      }

      Structure.prototype.structure = true;

      Structure.prototype.render = function(board) {
        var context;
        if (!board.visible(this.x, this.y, this.imageXOffset, this.imageYOffset * 2, this.imageYOffset)) {
          return;
        }
        context = board.context;
        context.save();
        context.globalAlpha = 0.9;
        context.drawImage(this.image, this.x - board.x - this.imageXOffset, (this.y - board.y) / 2 - this.imageYOffset);
        context.restore();
      };

      return Structure;

    })(Agent);
    RotatedSquareStructure = (function(_super) {
      __extends(RotatedSquareStructure, _super);

      function RotatedSquareStructure() {
        _ref2 = RotatedSquareStructure.__super__.constructor.apply(this, arguments);
        return _ref2;
      }

      RotatedSquareStructure.prototype.checkCollision = function(otherX, otherY, otherSize) {
        var diffX, diffY, distX, distY, manhattanishDist;
        diffX = this.x - otherX;
        diffY = this.y - otherY;
        distX = abs(diffX);
        distY = abs(diffY);
        manhattanishDist = distX + distY - (otherSize / 2);
        if (manhattanishDist > this.size / 2) {
          return false;
        }
        return {
          direction: atan2(diffY, diffX),
          distSquared: distX * distX + distY * distY
        };
      };

      RotatedSquareStructure.prototype.collisionTangent = function(other) {
        var diffX, diffY;
        diffX = this.x - other.x;
        diffY = this.y - other.y;
        if ((diffX < 0) ^ (diffY < 0)) {
          return QUARTER_PI;
        } else {
          return -QUARTER_PI;
        }
      };

      return RotatedSquareStructure;

    })(Structure);
    FarmHouse = (function(_super) {
      __extends(FarmHouse, _super);

      function FarmHouse() {
        _ref3 = FarmHouse.__super__.constructor.apply(this, arguments);
        return _ref3;
      }

      FarmHouse.prototype.size = 434;

      FarmHouse.prototype.imageYOffset = 352;

      FarmHouse.prototype.imageSrc = "images/farmhouse.png";

      return FarmHouse;

    })(RotatedSquareStructure);
    RotatedRectangleStructure = (function(_super) {
      __extends(RotatedRectangleStructure, _super);

      function RotatedRectangleStructure(game, x, y, slope) {
        if (slope) {
          this.slope = slope;
        }
        this.setStacking(x, y);
        RotatedRectangleStructure.__super__.constructor.apply(this, arguments);
      }

      RotatedRectangleStructure.prototype.setStacking = function(x, y) {
        var l, w;
        l = this.lengthComponent / 2;
        w = this.widthComponent / 2;
        if (this.slope > 0) {
          return this.stackingZones = [[x - l - w, y - l + w, x + l + w, y + l - w, y - l + w, (l - w) / (l + w)], [x - 2 * l, y - l + w, x - l - w, y + l - w, y, -1], [x + l + w, y - l + w, x + 2 * l, y + l - w, y + l - w, -1]];
        } else {
          return this.stackingZones = [[x - l - w, y - l + w, x + l + w, y + l - w, y + l - w, (w - l) / (l + w)], [x - 2 * l, y - l + w, x - l - w, y + l - w, y, 1], [x + l + w, y - l + w, x + 2 * l, y + l - w, y - l + w, 1]];
        }
      };

      RotatedRectangleStructure.prototype.checkCollision = function(otherX, otherY, otherSize) {
        var length, width, x, y;
        x = otherX - this.x;
        y = otherY - this.y;
        length = this.lengthComponent + otherSize / 2;
        width = this.widthComponent + otherSize / 2;
        if (this.slope > 0) {
          if (x - y > width || x - y < -width || x + y > length || x + y < -length) {
            return false;
          }
        } else {
          if (x + y > width || x + y < -width || x - y > length || x - y < -length) {
            return false;
          }
        }
        return {
          direction: atan2(-y, -x),
          distSquared: x * x + y * y
        };
      };

      RotatedRectangleStructure.prototype.collisionTangent = function(other) {
        var width, x, y;
        x = other.x - this.x;
        y = other.y - this.y;
        width = this.widthComponent;
        if (x + y >= width || x + y <= -width) {
          return -QUARTER_PI;
        } else {
          return QUARTER_PI;
        }
      };

      return RotatedRectangleStructure;

    })(Structure);
    MotorHome = (function(_super) {
      __extends(MotorHome, _super);

      function MotorHome() {
        _ref4 = MotorHome.__super__.constructor.apply(this, arguments);
        return _ref4;
      }

      MotorHome.prototype.imageXOffset = 123;

      MotorHome.prototype.imageYOffset = 146;

      MotorHome.prototype.imageSrc = "images/motorhome.png";

      MotorHome.prototype.lengthComponent = 190;

      MotorHome.prototype.widthComponent = 55;

      MotorHome.prototype.size = 245;

      MotorHome.prototype.slope = -1;

      return MotorHome;

    })(RotatedRectangleStructure);
    Tower = (function(_super) {
      __extends(Tower, _super);

      function Tower() {
        _ref5 = Tower.__super__.constructor.apply(this, arguments);
        return _ref5;
      }

      Tower.prototype.size = 74;

      Tower.prototype.imageXOffset = 72;

      Tower.prototype.imageYOffset = 223;

      Tower.prototype.imageSrc = "images/tower.png";

      return Tower;

    })(RotatedSquareStructure);
    Fence = (function(_super) {
      __extends(Fence, _super);

      Fence.prototype.size = 288;

      Fence.prototype.imageXOffset = 144;

      Fence.prototype.imageYOffset = 136;

      Fence.prototype.lengthComponent = 276;

      Fence.prototype.widthComponent = 12;

      Fence.prototype.imageSrc = "images/fence-se.png";

      function Fence(game, x, y, slope) {
        if (slope < 0) {
          this.imageSrc = "images/fence-ne.png";
        }
        Fence.__super__.constructor.apply(this, arguments);
      }

      return Fence;

    })(RotatedRectangleStructure);
    Structure.register('farmhouse', FarmHouse);
    Structure.register('motorhome', MotorHome);
    Structure.register('tower', Tower);
    Structure.register('fence', Fence);
    return window.Zomgbie = Zomgbie;
  })($);

}).call(this);
